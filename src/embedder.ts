import { FlagEmbedding, EmbeddingModel } from 'fastembed';
import { ModelInfo } from './types';
import { log } from './logging-utils';
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as path from 'path';

export class EmbeddingGenerator {
  private embedder: FlagEmbedding | null = null;
  private isInitialized = false;
  private readonly modelName = EmbeddingModel.BGESmallENV15;
  private modelVersion: string = '1.5.0';
  private modelHash: string | null = null;

  constructor() {
    // Model will be initialized on first use
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      try {
        // BGE initialization is announced by server stage tracker
        this.embedder = await FlagEmbedding.init({
          model: this.modelName,
          maxLength: 400,
          cacheDir: './.fastembed_cache'
        });
        
        // Calculate model hash for version tracking
        await this.calculateModelHash();
        
        this.isInitialized = true;
        log('[Embedder] Embedding model initialized successfully');
      } catch (error) {
        log(`[Embedder] Failed to initialize embedding model, using mock embeddings error=${error}`);
        this.embedder = null;
        this.isInitialized = true;
      }
    }
  }

  private async calculateModelHash(): Promise<void> {
    try {
      const modelDir = path.join('.fastembed_cache', 'fast-bge-small-en-v1.5');
      const modelFiles = await fs.readdir(modelDir).catch(() => []);
      
      if (modelFiles.length > 0) {
        // Hash the model directory contents for version tracking
        const hash = crypto.createHash('sha256');
        const sortedFiles = modelFiles.sort();
        
        for (const file of sortedFiles) {
          const filePath = path.join(modelDir, file);
          try {
            const stats = await fs.stat(filePath);
            if (stats.isFile()) {
              hash.update(`${file}:${stats.size}:${stats.mtime.getTime()}`);
            }
          } catch (error) {
            // Skip files that can't be read
          }
        }
        
        this.modelHash = hash.digest('hex').substring(0, 16);
      }
    } catch (error) {
      console.warn('Failed to calculate model hash:', error);
      this.modelHash = null;
    }
  }

  async embed(text: string): Promise<number[]> {
    await this.ensureInitialized();
    
    if (!this.embedder) {
      return this.generateMockEmbedding(text);
    }

    try {
      const embeddings = this.embedder.embed([text]);
      for await (const batch of embeddings) {
        return Array.from(batch[0]);
      }
      return this.generateMockEmbedding(text);
    } catch (error) {
      console.warn('Failed to generate embedding, using mock:', error);
      return this.generateMockEmbedding(text);
    }
  }

  async embedBatch(texts: string[]): Promise<number[][]> {
    await this.ensureInitialized();
    
    if (!this.embedder) {
      return texts.map(text => this.generateMockEmbedding(text));
    }

    try {
      const embeddings = this.embedder.embed(texts);
      const results: number[][] = [];
      for await (const batch of embeddings) {
        results.push(...batch.map(embedding => Array.from(embedding)));
      }
      return results;
    } catch (error) {
      console.warn('Failed to generate batch embeddings, using mock:', error);
      return texts.map(text => this.generateMockEmbedding(text));
    }
  }

  async getModelInfo(): Promise<ModelInfo> {
    await this.ensureInitialized();
    
    return {
      name: 'BGE-small-en-v1.5',
      version: this.modelVersion,
      hash: this.modelHash || undefined,
      dimension: 384, // BGE small model dimension
      isLoaded: this.embedder !== null
    };
  }

  /**
   * Validates if cached embeddings were generated by the current model
   */
  async validateModelCompatibility(cachedModelInfo?: { name?: string; version?: string; hash?: string }): Promise<{
    compatible: boolean;
    reason: string;
    recommendation: 'none' | 'reindex';
  }> {
    const currentModel = await this.getModelInfo();
    
    if (!cachedModelInfo) {
      return {
        compatible: true, // Assume compatible if no metadata (older embeddings still work)
        reason: 'No model information found in cached embeddings, assuming compatibility',
        recommendation: 'none'
      };
    }
    
    if (cachedModelInfo.name !== currentModel.name) {
      return {
        compatible: false,
        reason: `Model changed from ${cachedModelInfo.name} to ${currentModel.name}`,
        recommendation: 'reindex'
      };
    }
    
    if (cachedModelInfo.version !== currentModel.version) {
      return {
        compatible: false,
        reason: `Model version changed from ${cachedModelInfo.version} to ${currentModel.version}`,
        recommendation: 'reindex'
      };
    }
    
    if (cachedModelInfo.hash && currentModel.hash && cachedModelInfo.hash !== currentModel.hash) {
      return {
        compatible: false,
        reason: `Model files changed (hash mismatch)`,
        recommendation: 'reindex'
      };
    }
    
    return {
      compatible: true,
      reason: 'Model is compatible with cached embeddings',
      recommendation: 'none'
    };
  }

  private generateMockEmbedding(text: string): number[] {
    // Generate deterministic mock embedding based on text
    const dimension = 384; // Same as BGE small model
    const embedding = new Array(dimension);
    
    // Simple hash-based mock embedding
    let seed = this.hashString(text);
    for (let i = 0; i < dimension; i++) {
      seed = (seed * 9301 + 49297) % 233280;
      embedding[i] = (seed / 233280) * 2 - 1; // Normalize to [-1, 1]
    }
    
    return embedding;
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}